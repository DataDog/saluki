<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Building blocks for declaring and enforcing memory bounds for components."><title>memory_accounting - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="memory_accounting" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (57ef8d642 2025-10-15)" data-channel="nightly" data-search-js="search-8d3311b9.js" data-stringdex-js="stringdex-828709d0.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate memory_accounting</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../memory_accounting/index.html">memory_<wbr>accounting</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#overview" title="Overview">Overview</a></li><li><a href="#memory-bounds" title="Memory bounds">Memory bounds</a></li><li><a href="#allocation-tracking" title="Allocation tracking">Allocation tracking</a></li><li><a href="#memory-limiting" title="Memory limiting">Memory limiting</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>memory_<wbr>accounting</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/memory_accounting/lib.rs.html#1-280">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Building blocks for declaring and enforcing memory bounds for components.</p>
<h3 id="overview"><a class="doc-anchor" href="#overview">§</a>Overview</h3>
<p>This crate provides a three-pronged approach to memory accounting:</p>
<ul>
<li>memory bounds (components declare their <em>expected</em> memory usage)</li>
<li>allocation tracking (tracking <em>actual</em> memory usage)</li>
<li>memory limiting (enforcing <em>maximum</em> memory usage)</li>
</ul>
<p>Through this approach, data planes can be vastly more resilient to memory exhaustion or
exceeding externally-applied memory limits.</p>
<h3 id="memory-bounds"><a class="doc-anchor" href="#memory-bounds">§</a>Memory bounds</h3>
<p>One major problem with resource planning is predicting memory usage. For many applications,
there are a number of factors that can influence memory usage, such as:</p>
<ul>
<li>the workload itself (amount of data coming in)</li>
<li>application configuration (buffer sizes)</li>
<li>application changes (new features, bug fixes)</li>
</ul>
<p>This requires additional effort by operators, potentially on an ongoing basis, to empirically
determine the right amount of memory to dedicate. What if instead, an application could
determine a reasonable upper bound on its memory usage based on its configuration and report
that to the operator? This is the goal of memory bounds.</p>
<p>Memory bounds are a way for components to declare their expected memory usage, categorized into
both a minimum required amount and a firm limit. The minimum required amount is the amount of
memory that is required for the component to function correctly, which generally encompasses
things like pre-allocated buffers. The firm limit is meant to indicate the maximum amount of
memory that the component should use, regardless of the workload.</p>
<p>Providing firm limits does require some additional thought and care, as a component needs to be
able to actually limit itself in order to adhere to those limits. While determining the the
bounds themselves is out of scope for this crate, our other two prongs are meant to pick up the
slack where memory bounds fall off.</p>
<h3 id="allocation-tracking"><a class="doc-anchor" href="#allocation-tracking">§</a>Allocation tracking</h3>
<p>As memory bounds are inherently lossy, and not everything can be fully bounded, we need a way to
track the actual memory used against the expected memory usage. This is where allocation
tracking comes into play and offers a very precise view into per-component memory usage.</p>
<p>A custom allocator is provided that tracks all memory allocations, and more specifically,
attributes them to a set of registered components. Components register with the allocator and
receive a “token” that can be used to scope allocations to that component.</p>
<p>By tracking allocations in this way, we end up with the actual usage of each component, which
can then be compared against the memory bounds to determine if a component is exceeding its
bounds or not. In cases where a component is exceeding its bounds, or the application as a whole
is exceeding its configured limit, we need a way to attempt to enforce those limits.</p>
<h3 id="memory-limiting"><a class="doc-anchor" href="#memory-limiting">§</a>Memory limiting</h3>
<p>Memory limiting is the final prong in our approach to memory accounting.</p>
<p>When the application is approaching its configured memory limit, or is exceeding the limit, a
mechanism is needed to slow down the rate of memory growth. The global memory limiter is a
mechanism for cooperatively applying backpressure in order to limit the rate of work, and
thereby limit the rate of allocations. Components participate by utilizing the global memory
limiter, which conditionally applies small delays in order to artificially generate backpressure.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="allocator/index.html" title="mod memory_accounting::allocator">allocator</a></dt><dd>Global allocator implementation that allows tracking allocations on a per-group basis.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.BoundsVerifier.html" title="struct memory_accounting::BoundsVerifier">Bounds<wbr>Verifier</a></dt><dd>Memory bounds verifier.</dd><dt><a class="struct" href="struct.ComponentBounds.html" title="struct memory_accounting::ComponentBounds">Component<wbr>Bounds</a></dt><dd>Memory bounds for a component.</dd><dt><a class="struct" href="struct.ComponentRegistry.html" title="struct memory_accounting::ComponentRegistry">Component<wbr>Registry</a></dt><dd>A registry for components for tracking memory bounds and runtime memory usage.</dd><dt><a class="struct" href="struct.MemoryAPIHandler.html" title="struct memory_accounting::MemoryAPIHandler">MemoryAPI<wbr>Handler</a></dt><dd>An API handler for reporting the memory bounds and usage of all components.</dd><dt><a class="struct" href="struct.MemoryBoundsBuilder.html" title="struct memory_accounting::MemoryBoundsBuilder">Memory<wbr>Bounds<wbr>Builder</a></dt><dd>Builder for defining the memory bounds of a component and its subcomponents.</dd><dt><a class="struct" href="struct.MemoryGrant.html" title="struct memory_accounting::MemoryGrant">Memory<wbr>Grant</a></dt><dd>A memory grant.</dd><dt><a class="struct" href="struct.MemoryLimiter.html" title="struct memory_accounting::MemoryLimiter">Memory<wbr>Limiter</a></dt><dd>A process-wide memory limiter.</dd><dt><a class="struct" href="struct.VerifiedBounds.html" title="struct memory_accounting::VerifiedBounds">Verified<wbr>Bounds</a></dt><dd>Verified bounds.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.UsageExpr.html" title="enum memory_accounting::UsageExpr">Usage<wbr>Expr</a></dt><dd>Represents a memory usage expression for a component.</dd><dt><a class="enum" href="enum.VerifierError.html" title="enum memory_accounting::VerifierError">Verifier<wbr>Error</a></dt><dd>A verification error.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.MemoryBounds.html" title="trait memory_accounting::MemoryBounds">Memory<wbr>Bounds</a></dt><dd>Memory bounds for a component.</dd></dl></section></div></main></body></html>